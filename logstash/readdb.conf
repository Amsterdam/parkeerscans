
input {
    jdbc {
        # Postgres jdbc connection string to our database, mydb
        jdbc_connection_string => "jdbc:postgresql://database:5432/predictiveparking"
        # The user we wish to execute our statement as
        jdbc_user => "predictiveparking"
        jdbc_password => "insecure"
	jdbc_page_size => 10000
	jdbc_paging_enabled => true
        # The path to our downloaded jdbc driver
        jdbc_driver_library => "/app/postgresql-9.4.1212.jar"
        # The name of the driver class for Postgresql
        jdbc_driver_class => "org.postgresql.Driver"
        statement => 'SELECT scan_moment, scan_id, scan_source, sperscode, qualcode, ff_df,  nha_hoogte, bgt_wegdeel, bgt_wegdeel_functie, buurtcode, buurtcombinatie, stadsdeel, parkeervak_id, parkeervak_soort,round(ST_Y(geometrie)::numeric,8) as lat, round(ST_X(geometrie)::numeric,8) as lon from scans_scan'
        #statement => "SELECT * from scans_scan LIMIT 5"
    }
}

filter {

  ruby {
    code => "event.set('@timestamp', event.get('scan_moment'))"
  }

  mutate {
      remove_field => ["scan_moment"]
  }

  if [lat] and [lon] {

    mutate {
      add_field => {
        "[geo][lat]" => "%{lat}"
        "[geo][lon]" => "%{lon}"
      }
    }

    mutate {
      convert => {
       "[geo][lat]" => "float"
       "[geo][lon]" => "float"
      }
    }

    mutate {
      remove_field => ["lat", "lon"]
    }

  } else {
    drop {}
  }
}

#output {
#    stdout { codec => rubydebug }
#}

output {
    elasticsearch {
	index => "scans-%{+YYYY.MM.dd}"
	sniffing => false
	document_type => "scan"
       template => "geomapping.json"
	hosts => ["elasticsearch"]
    }
}
