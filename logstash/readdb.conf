
input {
    jdbc {
        # Postgres jdbc connection string to our database, mydb
        jdbc_connection_string => "jdbc:postgresql://database:5432/predictiveparking"

        # The user we wish to execute our statement as
        jdbc_user => "predictiveparking"
        jdbc_password => "insecure"
        jdbc_page_size => 20000
        jdbc_paging_enabled => true

        # The path to our downloaded jdbc driver
        jdbc_driver_library => "/app/postgresql-9.4.1212.jar"

        # The name of the driver class for Postgresql
        jdbc_driver_class => "org.postgresql.Driver"
        statement => "
          SELECT
	     id,
             scan_moment, scan_id, scan_source, sperscode, qualcode, ff_df,
             ROUND(nha_hoogte) as naheffing_hoogte, bgt_wegdeel, bgt_wegdeel_functie, buurtcode, buurtcombinatie,
             stadsdeel, parkeervak_id, parkeervak_soort,
             round(ST_Y(geometrie)::numeric,8) as lat, round(ST_X(geometrie)::numeric,8) as lon,
             EXTRACT(HOUR FROM scan_moment)::int as hour,
             EXTRACT(WEEK FROM scan_moment)::int as week,
             EXTRACT(YEAR FROM scan_moment)::int as year,
             EXTRACT(DOY FROM scan_moment)::int as day_of_year,
             EXTRACT(MINUTE FROM scan_moment)::int as minute,
             EXTRACT(SECOND FROM scan_moment)::int as second,
             to_char(scan_moment, 'month') as month,
             to_char(scan_moment, 'day') as day,

	     CASE
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (9, 10, 11) THEN '9-11'
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (11, 12, 13) THEN '11-13'
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (13, 14, 15) THEN '13-15'
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (16, 17, 18) THEN '16-18'
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (19, 20, 21) THEN '19-21'
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (21, 22, 23) THEN '21-23'
                WHEN EXTRACT(HOUR FROM scan_moment)::int IN (0, 1, 3, 4, 5, 6) THEN '0-6'
             END as shiftrange

          FROM ${TABLE}
          ORDER BY scan_moment"
    }
}

filter {

  ruby {
    code => "event.set('@timestamp', event.get('scan_moment'))"
  }

  mutate {
      remove_field => ["scan_moment"]
  }

  if [lat] and [lon] {

    mutate {
      add_field => {
        "[geo][lat]" => "%{lat}"
        "[geo][lon]" => "%{lon}"
      }
    }

    mutate {
      convert => {
       "[geo][lat]" => "float"
       "[geo][lon]" => "float"
      }
    }

    mutate {
      remove_field => ["lat", "lon"]
    }

  } else {
    drop {}
  }
}

#output {
#    stdout { codec => rubydebug }
#}

output {
    elasticsearch {
  index => "scans-%{+YYYY.MM.dd}"
  sniffing => false
  document_id => "%{id}-{scan_id}"
  template_name => "logscans"
  document_type => "scan"
  hosts => ["elasticsearch"]
  # hosts => ["es01-acc.datapunt.amsterdam.nl", "es02-acc.datapunt.amsterdam.nl", "es03-acc.datapunt.amsterdam.nl"]
    }
}
