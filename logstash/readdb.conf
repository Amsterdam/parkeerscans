
input {
    jdbc {
        # Postgres jdbc connection string to our database, mydb
        jdbc_connection_string => "jdbc:postgresql://database:5432/predictiveparking"
        # The user we wish to execute our statement as
        jdbc_user => "predictiveparking"
        jdbc_password => "insecure"
	jdbc_page_size => 20000
	jdbc_paging_enabled => true
        # The path to our downloaded jdbc driver
        jdbc_driver_library => "/app/postgresql-9.4.1212.jar"
        # The name of the driver class for Postgresql
        jdbc_driver_class => "org.postgresql.Driver"
        statement => "
SELECT id,
   scan_moment, scan_id, scan_source, sperscode, qualcode, ff_df,
   nha_hoogte, bgt_wegdeel, bgt_wegdeel_functie, buurtcode, buurtcombinatie,
   stadsdeel, parkeervak_id, parkeervak_soort,
   round(ST_Y(geometrie)::numeric,8) as lat, round(ST_X(geometrie)::numeric,8) as lon,
   EXTRACT(HOUR FROM scan_moment)::int as uur,
   EXTRACT(WEEK FROM scan_moment)::int as week,
   EXTRACT(YEAR FROM scan_moment)::int as jaar,
   EXTRACT(DOY FROM scan_moment)::int as day_of_year,
   to_char(scan_moment, 'month') as maand,
   to_char(scan_moment, 'day') as dag
 FROM scans_scan
 WHERE
   scan_moment >= '${START_DATE}'::date
   AND scan_moment <  '${END_DATE}'::date
 ORDER BY scan_moment"
    }
}

filter {

  ruby {
    code => "event.set('@timestamp', event.get('scan_moment'))"
  }

  mutate {
      remove_field => ["scan_moment"]
  }

  if [lat] and [lon] {

    mutate {
      add_field => {
        "[geo][lat]" => "%{lat}"
        "[geo][lon]" => "%{lon}"
      }
    }

    mutate {
      convert => {
       "[geo][lat]" => "float"
       "[geo][lon]" => "float"
      }
    }

    mutate {
      remove_field => ["lat", "lon"]
    }

  } else {
    drop {}
  }
}

#output {
#    stdout { codec => rubydebug }
#}

output {
    elasticsearch {
	index => "scans-%{+YYYY.MM.dd}"
	sniffing => false
	document_id => "%{id}"
	template_name => "logscans"
	document_type => "scan"
	hosts => ["elasticsearch"]
    }
}
